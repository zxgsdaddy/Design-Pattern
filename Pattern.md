###  工厂方法模式的扩展
	1. 缩小为简单工厂模式
	2. 升级为多个工厂类
	3. 替代单例模式
	4. 延迟初始化

###  模板方法模式的扩展
	在我们的抽象类中的返回值就是影响了模板方法的执行结果，该方法就叫做钩子方法（Hook Method）。有了钩子方法模板方法模式才算完美。

###  建造者模式的使用场景
	1.相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。
 	2.多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。
 	3.产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。
	4.在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时，也可以采用建造者模式封装该对象的创建过程。该种场景只能是一个补偿方法，因为一个对象不容易获得，而在设计阶段竟然没有发觉，而要通过创建者模式柔化创建过程，本身已经违反设计的最初目标。

###  代理模式
	1. 普通代理
	2. 强制代理
	3.  代理是有个性的
		一个类可以实现多个接口，完成不同任务的整合。也就是说代理类不仅仅可以实现主题接口，也可以实现其他接口完成不同的任务，而且代理的目的是在目标对象方法的基础上作增强，这种增强的本质通常就是对目标对象的方法进行拦截和过滤
	4. 动态代理

###  原型模式

###  中介者模式

###  命令模式

###  责任链模式
	1.责任链模式的优点
	责任链模式非常显著的优点是将请求和处理分开。请求者可以不用知道是谁处理的，处理者可以不用知道请求的全貌，两者解耦，提高系统的灵活性。
	2.责任链模式的缺点
	责任链有两个非常显著的缺点：一是性能问题，每个请求都是从链头遍历到链尾，特别是在链比较长的时候，性能是一个非常大的问题。二是调试不很方便，特别是链条比较长，环节比较多的时候，由于采用了类似递归的方式，调试的时候逻辑可能比较复杂。
	3.责任链模式的注意事项
	链中节点数量需要控制，避免出现超长链的情况，一般的做法是在Handler中设置一个最大节点数量，在setNext方法中判断是否已经是超过其阈值，超过则不允许该链建立，避免无意识地破坏系统性能。

###  装饰器模式
	装饰模式是对继承的有力补充

###  策略模式
	如果系统中的一个策略家族的具体策略数量超过4个，则需要考虑使用混合模式，解决策略类膨胀和对外暴露的问题。
	策略枚举

###  适配器模式
	适配器模式最好在详细设计阶段不要考虑它，它不是为了解决还处在开发阶段的问题，而是解决正在服役的项目问题，没有一个系统分析师会在做详细设计的时候考虑使用适配器模式，这个模式使用的主要场景是扩展应用中。


###  迭代器模式

###  组合模式

###  观察者模式
	使用观察者模式也有以下两个重点问题要解决。
	1 广播链的问题
	一个观察者可以有双重身份，既是观察者，也是被观察者，但是链一旦建立，这个逻辑就比较复杂，可维护性非常差，根据经验建议，在一个观察者模式中最多出现一个对象既是观察者也是被观察者，也就是说消息最多转发一次（传递两次），这还是比较好控制的。

	注意　它和责任链模式的最大区别就是观察者广播链在传播的过程中消息是随时更改的，它是由相邻的两个节点协商的消息结构；而责任链模式在消息传递过程中基本上保持消息不可变，如果要改变，也只是在原有的消息上进行修正。

	2 异步处理问题

###  门面模式（外观模式）
	金玉其外，败絮其中
	1.为一个复杂的模块或子系统提供一个供外界访问的接口
	2.子系统相对独立——外界对子系统的访问只要黑箱操作即可
	3.预防低水平人员带来的风险扩散
	4.一个子系统可以有多个门面

###  备忘录模式
	设计的时候就不要使用数据库的临时表作为缓存备份数据了，虽然是一个简单的办法，但是它加大了数据库操作的频繁度，把压力下放到数据库了，最好的解决办法就是使用备忘录模式。
	双接口设计，我们的一个类可以实现多个接口，在系统设计时，如果考虑对象的安全问题，则可以提供两个接口，一个是业务的正常接口，实现必要的业务逻辑，叫做宽接口；另外一个接口是一个空接口，什么方法都没有，其目的是提供给子系统外的模块访问，比如容器对象，这个叫做窄接口，由于窄接口中没有提供任何操纵数据的方法，因此相对来说比较安全。

###  访问者模式
	1.一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作，也就说是用迭代器模式已经不能胜任的情景。
	2.需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。
	访问者模式是一种集中规整模式，特别适用于大规模重构的项目，在这一个阶段需求已经非常清晰，原系统的功能点也已经明确，通过访问者模式可以很容易把一些功能进行梳理，达到最终目的——功能集中化。

###  状态模式
	1.行为随状态改变而改变的场景
	2.条件、分支判断语句的替代者

###  状态模式
	1.系统中存在大量的相似对象。
	2.细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。
	3.需要缓冲池的场景。

###  桥梁模式
	1.桥梁模式的优点
	● 抽象和实现分离
	这也是桥梁模式的主要特点，它完全是为了解决继承的缺点而提出的设计模式。在该模式下，实现可以不受抽象的约束，不用再绑定在一个固定的抽象层次上。
	● 优秀的扩充能力
	看看我们的例子，想增加实现？没问题！想增加抽象，也没有问题！只要对外暴露的接口层允许这样的变化，我们已经把变化的可能性减到最小。
	● 实现细节对客户透明
	客户不用关心细节的实现，它已经由抽象层通过聚合关系完成了封装。

	2.桥梁模式的使用场景
	● 不希望或不适用使用继承的场景
	例如继承层次过渡、无法更细化设计颗粒等场景，需要考虑使用桥梁模式。
	● 接口或抽象类不稳定的场景
	明知道接口不稳定还想通过实现或继承来实现业务需求，那是得不偿失的，也是比较失败的做法。
	● 重用性要求较高的场景
	设计的颗粒度越细，则被重用的可能性就越大，而采用继承则受父类的限制，不可能出现太细的颗粒度。

	3.桥梁模式的注意事项
	桥梁模式是非常简单的，使用该模式时主要考虑如何拆分抽象和实现，并不是一涉及继承就要考虑使用该模式，那还要继承干什么呢？桥梁模式的意图还是对变化的封装，尽量把可能变化的因素封装到最细、最小的逻辑单元中，避免风险扩散。因此读者在进行系统设计时，发现类的继承有N层时，可以考虑使用桥梁模式。